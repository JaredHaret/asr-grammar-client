// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: asr_service.proto

#ifndef PROTOBUF_asr_5fservice_2eproto__INCLUDED
#define PROTOBUF_asr_5fservice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace sarmata {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_asr_5fservice_2eproto();
void protobuf_AssignDesc_asr_5fservice_2eproto();
void protobuf_ShutdownFile_asr_5fservice_2eproto();

class AudioRequest;
class ConfigField;
class DefineGrammarRequest;
class DefineGrammarRespone;
class InitialRecognizeRequest;
class InterpretRequest;
class InterpretResponse;
class Phrase;
class Phrase_Word;
class RecognizeRequest;
class RecognizeResponse;

enum ResponseStatus {
  SUCCESS = 0,
  PARTIAL_MATCH = 1,
  NO_MATCH = 2,
  NO_INPUT_TIMEOUT = 3,
  RECOGNITION_TIMEOUT = 4,
  GRAMMAR_LOAD_FAILURE = 5,
  GRAMMAR_COMPILATION_FAILURE = 6,
  RECOGNIZER_ERROR = 7,
  TOO_MUCH_SPEECH_TIMEOUT = 8,
  URI_FAILURE = 9,
  LANGUAGE_UNSUPPORTED = 10,
  CANCELLED = 11,
  START_OF_INPUT = 12,
  END_OF_AUDIO = 13,
  ResponseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ResponseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ResponseStatus_IsValid(int value);
const ResponseStatus ResponseStatus_MIN = SUCCESS;
const ResponseStatus ResponseStatus_MAX = END_OF_AUDIO;
const int ResponseStatus_ARRAYSIZE = ResponseStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseStatus_descriptor();
inline const ::std::string& ResponseStatus_Name(ResponseStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseStatus_descriptor(), value);
}
inline bool ResponseStatus_Parse(
    const ::std::string& name, ResponseStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseStatus>(
    ResponseStatus_descriptor(), name, value);
}
// ===================================================================

class RecognizeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sarmata.RecognizeRequest) */ {
 public:
  RecognizeRequest();
  virtual ~RecognizeRequest();

  RecognizeRequest(const RecognizeRequest& from);

  inline RecognizeRequest& operator=(const RecognizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecognizeRequest& default_instance();

  void Swap(RecognizeRequest* other);

  // implements Message ----------------------------------------------

  inline RecognizeRequest* New() const { return New(NULL); }

  RecognizeRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecognizeRequest& from);
  void MergeFrom(const RecognizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecognizeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sarmata.InitialRecognizeRequest initial_request = 1;
  bool has_initial_request() const;
  void clear_initial_request();
  static const int kInitialRequestFieldNumber = 1;
  const ::sarmata::InitialRecognizeRequest& initial_request() const;
  ::sarmata::InitialRecognizeRequest* mutable_initial_request();
  ::sarmata::InitialRecognizeRequest* release_initial_request();
  void set_allocated_initial_request(::sarmata::InitialRecognizeRequest* initial_request);

  // optional .sarmata.AudioRequest audio_request = 2;
  bool has_audio_request() const;
  void clear_audio_request();
  static const int kAudioRequestFieldNumber = 2;
  const ::sarmata::AudioRequest& audio_request() const;
  ::sarmata::AudioRequest* mutable_audio_request();
  ::sarmata::AudioRequest* release_audio_request();
  void set_allocated_audio_request(::sarmata::AudioRequest* audio_request);

  // @@protoc_insertion_point(class_scope:sarmata.RecognizeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::sarmata::InitialRecognizeRequest* initial_request_;
  ::sarmata::AudioRequest* audio_request_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_asr_5fservice_2eproto();
  friend void protobuf_AssignDesc_asr_5fservice_2eproto();
  friend void protobuf_ShutdownFile_asr_5fservice_2eproto();

  void InitAsDefaultInstance();
  static RecognizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConfigField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sarmata.ConfigField) */ {
 public:
  ConfigField();
  virtual ~ConfigField();

  ConfigField(const ConfigField& from);

  inline ConfigField& operator=(const ConfigField& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigField& default_instance();

  void Swap(ConfigField* other);

  // implements Message ----------------------------------------------

  inline ConfigField* New() const { return New(NULL); }

  ConfigField* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfigField& from);
  void MergeFrom(const ConfigField& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:sarmata.ConfigField)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_asr_5fservice_2eproto();
  friend void protobuf_AssignDesc_asr_5fservice_2eproto();
  friend void protobuf_ShutdownFile_asr_5fservice_2eproto();

  void InitAsDefaultInstance();
  static ConfigField* default_instance_;
};
// -------------------------------------------------------------------

class InitialRecognizeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sarmata.InitialRecognizeRequest) */ {
 public:
  InitialRecognizeRequest();
  virtual ~InitialRecognizeRequest();

  InitialRecognizeRequest(const InitialRecognizeRequest& from);

  inline InitialRecognizeRequest& operator=(const InitialRecognizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitialRecognizeRequest& default_instance();

  void Swap(InitialRecognizeRequest* other);

  // implements Message ----------------------------------------------

  inline InitialRecognizeRequest* New() const { return New(NULL); }

  InitialRecognizeRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitialRecognizeRequest& from);
  void MergeFrom(const InitialRecognizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitialRecognizeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sarmata.ConfigField config = 1;
  int config_size() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::sarmata::ConfigField& config(int index) const;
  ::sarmata::ConfigField* mutable_config(int index);
  ::sarmata::ConfigField* add_config();
  ::google::protobuf::RepeatedPtrField< ::sarmata::ConfigField >*
      mutable_config();
  const ::google::protobuf::RepeatedPtrField< ::sarmata::ConfigField >&
      config() const;

  // optional string token = 2;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:sarmata.InitialRecognizeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::sarmata::ConfigField > config_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_asr_5fservice_2eproto();
  friend void protobuf_AssignDesc_asr_5fservice_2eproto();
  friend void protobuf_ShutdownFile_asr_5fservice_2eproto();

  void InitAsDefaultInstance();
  static InitialRecognizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class AudioRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sarmata.AudioRequest) */ {
 public:
  AudioRequest();
  virtual ~AudioRequest();

  AudioRequest(const AudioRequest& from);

  inline AudioRequest& operator=(const AudioRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioRequest& default_instance();

  void Swap(AudioRequest* other);

  // implements Message ----------------------------------------------

  inline AudioRequest* New() const { return New(NULL); }

  AudioRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioRequest& from);
  void MergeFrom(const AudioRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes content = 1;
  void clear_content();
  static const int kContentFieldNumber = 1;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // optional bool end_of_stream = 2;
  void clear_end_of_stream();
  static const int kEndOfStreamFieldNumber = 2;
  bool end_of_stream() const;
  void set_end_of_stream(bool value);

  // @@protoc_insertion_point(class_scope:sarmata.AudioRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  bool end_of_stream_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_asr_5fservice_2eproto();
  friend void protobuf_AssignDesc_asr_5fservice_2eproto();
  friend void protobuf_ShutdownFile_asr_5fservice_2eproto();

  void InitAsDefaultInstance();
  static AudioRequest* default_instance_;
};
// -------------------------------------------------------------------

class InterpretRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sarmata.InterpretRequest) */ {
 public:
  InterpretRequest();
  virtual ~InterpretRequest();

  InterpretRequest(const InterpretRequest& from);

  inline InterpretRequest& operator=(const InterpretRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterpretRequest& default_instance();

  void Swap(InterpretRequest* other);

  // implements Message ----------------------------------------------

  inline InterpretRequest* New() const { return New(NULL); }

  InterpretRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InterpretRequest& from);
  void MergeFrom(const InterpretRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InterpretRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // optional string grammar = 2;
  void clear_grammar();
  static const int kGrammarFieldNumber = 2;
  const ::std::string& grammar() const;
  void set_grammar(const ::std::string& value);
  void set_grammar(const char* value);
  void set_grammar(const char* value, size_t size);
  ::std::string* mutable_grammar();
  ::std::string* release_grammar();
  void set_allocated_grammar(::std::string* grammar);

  // optional string sentence = 3;
  void clear_sentence();
  static const int kSentenceFieldNumber = 3;
  const ::std::string& sentence() const;
  void set_sentence(const ::std::string& value);
  void set_sentence(const char* value);
  void set_sentence(const char* value, size_t size);
  ::std::string* mutable_sentence();
  ::std::string* release_sentence();
  void set_allocated_sentence(::std::string* sentence);

  // @@protoc_insertion_point(class_scope:sarmata.InterpretRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::internal::ArenaStringPtr grammar_;
  ::google::protobuf::internal::ArenaStringPtr sentence_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_asr_5fservice_2eproto();
  friend void protobuf_AssignDesc_asr_5fservice_2eproto();
  friend void protobuf_ShutdownFile_asr_5fservice_2eproto();

  void InitAsDefaultInstance();
  static InterpretRequest* default_instance_;
};
// -------------------------------------------------------------------

class InterpretResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sarmata.InterpretResponse) */ {
 public:
  InterpretResponse();
  virtual ~InterpretResponse();

  InterpretResponse(const InterpretResponse& from);

  inline InterpretResponse& operator=(const InterpretResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterpretResponse& default_instance();

  void Swap(InterpretResponse* other);

  // implements Message ----------------------------------------------

  inline InterpretResponse* New() const { return New(NULL); }

  InterpretResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InterpretResponse& from);
  void MergeFrom(const InterpretResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InterpretResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error = 1;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // repeated string si = 2;
  int si_size() const;
  void clear_si();
  static const int kSiFieldNumber = 2;
  const ::std::string& si(int index) const;
  ::std::string* mutable_si(int index);
  void set_si(int index, const ::std::string& value);
  void set_si(int index, const char* value);
  void set_si(int index, const char* value, size_t size);
  ::std::string* add_si();
  void add_si(const ::std::string& value);
  void add_si(const char* value);
  void add_si(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& si() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_si();

  // @@protoc_insertion_point(class_scope:sarmata.InterpretResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::RepeatedPtrField< ::std::string> si_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_asr_5fservice_2eproto();
  friend void protobuf_AssignDesc_asr_5fservice_2eproto();
  friend void protobuf_ShutdownFile_asr_5fservice_2eproto();

  void InitAsDefaultInstance();
  static InterpretResponse* default_instance_;
};
// -------------------------------------------------------------------

class DefineGrammarRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sarmata.DefineGrammarRequest) */ {
 public:
  DefineGrammarRequest();
  virtual ~DefineGrammarRequest();

  DefineGrammarRequest(const DefineGrammarRequest& from);

  inline DefineGrammarRequest& operator=(const DefineGrammarRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DefineGrammarRequest& default_instance();

  void Swap(DefineGrammarRequest* other);

  // implements Message ----------------------------------------------

  inline DefineGrammarRequest* New() const { return New(NULL); }

  DefineGrammarRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DefineGrammarRequest& from);
  void MergeFrom(const DefineGrammarRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DefineGrammarRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string grammar = 3;
  void clear_grammar();
  static const int kGrammarFieldNumber = 3;
  const ::std::string& grammar() const;
  void set_grammar(const ::std::string& value);
  void set_grammar(const char* value);
  void set_grammar(const char* value, size_t size);
  ::std::string* mutable_grammar();
  ::std::string* release_grammar();
  void set_allocated_grammar(::std::string* grammar);

  // @@protoc_insertion_point(class_scope:sarmata.DefineGrammarRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr grammar_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_asr_5fservice_2eproto();
  friend void protobuf_AssignDesc_asr_5fservice_2eproto();
  friend void protobuf_ShutdownFile_asr_5fservice_2eproto();

  void InitAsDefaultInstance();
  static DefineGrammarRequest* default_instance_;
};
// -------------------------------------------------------------------

class DefineGrammarRespone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sarmata.DefineGrammarRespone) */ {
 public:
  DefineGrammarRespone();
  virtual ~DefineGrammarRespone();

  DefineGrammarRespone(const DefineGrammarRespone& from);

  inline DefineGrammarRespone& operator=(const DefineGrammarRespone& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DefineGrammarRespone& default_instance();

  void Swap(DefineGrammarRespone* other);

  // implements Message ----------------------------------------------

  inline DefineGrammarRespone* New() const { return New(NULL); }

  DefineGrammarRespone* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DefineGrammarRespone& from);
  void MergeFrom(const DefineGrammarRespone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DefineGrammarRespone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error = 1;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // optional string grammarName = 2;
  void clear_grammarname();
  static const int kGrammarNameFieldNumber = 2;
  const ::std::string& grammarname() const;
  void set_grammarname(const ::std::string& value);
  void set_grammarname(const char* value);
  void set_grammarname(const char* value, size_t size);
  ::std::string* mutable_grammarname();
  ::std::string* release_grammarname();
  void set_allocated_grammarname(::std::string* grammarname);

  // @@protoc_insertion_point(class_scope:sarmata.DefineGrammarRespone)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::internal::ArenaStringPtr grammarname_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_asr_5fservice_2eproto();
  friend void protobuf_AssignDesc_asr_5fservice_2eproto();
  friend void protobuf_ShutdownFile_asr_5fservice_2eproto();

  void InitAsDefaultInstance();
  static DefineGrammarRespone* default_instance_;
};
// -------------------------------------------------------------------

class RecognizeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sarmata.RecognizeResponse) */ {
 public:
  RecognizeResponse();
  virtual ~RecognizeResponse();

  RecognizeResponse(const RecognizeResponse& from);

  inline RecognizeResponse& operator=(const RecognizeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecognizeResponse& default_instance();

  void Swap(RecognizeResponse* other);

  // implements Message ----------------------------------------------

  inline RecognizeResponse* New() const { return New(NULL); }

  RecognizeResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecognizeResponse& from);
  void MergeFrom(const RecognizeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecognizeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sarmata.ResponseStatus status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::sarmata::ResponseStatus status() const;
  void set_status(::sarmata::ResponseStatus value);

  // optional string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // optional string warning = 3;
  void clear_warning();
  static const int kWarningFieldNumber = 3;
  const ::std::string& warning() const;
  void set_warning(const ::std::string& value);
  void set_warning(const char* value);
  void set_warning(const char* value, size_t size);
  ::std::string* mutable_warning();
  ::std::string* release_warning();
  void set_allocated_warning(::std::string* warning);

  // optional int32 event_time = 4;
  void clear_event_time();
  static const int kEventTimeFieldNumber = 4;
  ::google::protobuf::int32 event_time() const;
  void set_event_time(::google::protobuf::int32 value);

  // repeated .sarmata.Phrase results = 5;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 5;
  const ::sarmata::Phrase& results(int index) const;
  ::sarmata::Phrase* mutable_results(int index);
  ::sarmata::Phrase* add_results();
  ::google::protobuf::RepeatedPtrField< ::sarmata::Phrase >*
      mutable_results();
  const ::google::protobuf::RepeatedPtrField< ::sarmata::Phrase >&
      results() const;

  // @@protoc_insertion_point(class_scope:sarmata.RecognizeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  int status_;
  ::google::protobuf::int32 event_time_;
  ::google::protobuf::internal::ArenaStringPtr warning_;
  ::google::protobuf::RepeatedPtrField< ::sarmata::Phrase > results_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_asr_5fservice_2eproto();
  friend void protobuf_AssignDesc_asr_5fservice_2eproto();
  friend void protobuf_ShutdownFile_asr_5fservice_2eproto();

  void InitAsDefaultInstance();
  static RecognizeResponse* default_instance_;
};
// -------------------------------------------------------------------

class Phrase_Word : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sarmata.Phrase.Word) */ {
 public:
  Phrase_Word();
  virtual ~Phrase_Word();

  Phrase_Word(const Phrase_Word& from);

  inline Phrase_Word& operator=(const Phrase_Word& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Phrase_Word& default_instance();

  void Swap(Phrase_Word* other);

  // implements Message ----------------------------------------------

  inline Phrase_Word* New() const { return New(NULL); }

  Phrase_Word* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Phrase_Word& from);
  void MergeFrom(const Phrase_Word& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Phrase_Word* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string transcript = 1;
  void clear_transcript();
  static const int kTranscriptFieldNumber = 1;
  const ::std::string& transcript() const;
  void set_transcript(const ::std::string& value);
  void set_transcript(const char* value);
  void set_transcript(const char* value, size_t size);
  ::std::string* mutable_transcript();
  ::std::string* release_transcript();
  void set_allocated_transcript(::std::string* transcript);

  // optional double confidence = 2;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  double confidence() const;
  void set_confidence(double value);

  // optional int32 start = 3;
  void clear_start();
  static const int kStartFieldNumber = 3;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // optional int32 end = 4;
  void clear_end();
  static const int kEndFieldNumber = 4;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // optional double logprob = 5;
  void clear_logprob();
  static const int kLogprobFieldNumber = 5;
  double logprob() const;
  void set_logprob(double value);

  // @@protoc_insertion_point(class_scope:sarmata.Phrase.Word)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr transcript_;
  double confidence_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  double logprob_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_asr_5fservice_2eproto();
  friend void protobuf_AssignDesc_asr_5fservice_2eproto();
  friend void protobuf_ShutdownFile_asr_5fservice_2eproto();

  void InitAsDefaultInstance();
  static Phrase_Word* default_instance_;
};
// -------------------------------------------------------------------

class Phrase : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sarmata.Phrase) */ {
 public:
  Phrase();
  virtual ~Phrase();

  Phrase(const Phrase& from);

  inline Phrase& operator=(const Phrase& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Phrase& default_instance();

  void Swap(Phrase* other);

  // implements Message ----------------------------------------------

  inline Phrase* New() const { return New(NULL); }

  Phrase* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Phrase& from);
  void MergeFrom(const Phrase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Phrase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Phrase_Word Word;

  // accessors -------------------------------------------------------

  // repeated .sarmata.Phrase.Word words = 1;
  int words_size() const;
  void clear_words();
  static const int kWordsFieldNumber = 1;
  const ::sarmata::Phrase_Word& words(int index) const;
  ::sarmata::Phrase_Word* mutable_words(int index);
  ::sarmata::Phrase_Word* add_words();
  ::google::protobuf::RepeatedPtrField< ::sarmata::Phrase_Word >*
      mutable_words();
  const ::google::protobuf::RepeatedPtrField< ::sarmata::Phrase_Word >&
      words() const;

  // optional double confidence = 2;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  double confidence() const;
  void set_confidence(double value);

  // optional bool correct = 3;
  void clear_correct();
  static const int kCorrectFieldNumber = 3;
  bool correct() const;
  void set_correct(bool value);

  // optional string semantic_interpretation = 4;
  void clear_semantic_interpretation();
  static const int kSemanticInterpretationFieldNumber = 4;
  const ::std::string& semantic_interpretation() const;
  void set_semantic_interpretation(const ::std::string& value);
  void set_semantic_interpretation(const char* value);
  void set_semantic_interpretation(const char* value, size_t size);
  ::std::string* mutable_semantic_interpretation();
  ::std::string* release_semantic_interpretation();
  void set_allocated_semantic_interpretation(::std::string* semantic_interpretation);

  // @@protoc_insertion_point(class_scope:sarmata.Phrase)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::sarmata::Phrase_Word > words_;
  double confidence_;
  ::google::protobuf::internal::ArenaStringPtr semantic_interpretation_;
  bool correct_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_asr_5fservice_2eproto();
  friend void protobuf_AssignDesc_asr_5fservice_2eproto();
  friend void protobuf_ShutdownFile_asr_5fservice_2eproto();

  void InitAsDefaultInstance();
  static Phrase* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RecognizeRequest

// optional .sarmata.InitialRecognizeRequest initial_request = 1;
inline bool RecognizeRequest::has_initial_request() const {
  return !_is_default_instance_ && initial_request_ != NULL;
}
inline void RecognizeRequest::clear_initial_request() {
  if (GetArenaNoVirtual() == NULL && initial_request_ != NULL) delete initial_request_;
  initial_request_ = NULL;
}
inline const ::sarmata::InitialRecognizeRequest& RecognizeRequest::initial_request() const {
  // @@protoc_insertion_point(field_get:sarmata.RecognizeRequest.initial_request)
  return initial_request_ != NULL ? *initial_request_ : *default_instance_->initial_request_;
}
inline ::sarmata::InitialRecognizeRequest* RecognizeRequest::mutable_initial_request() {
  
  if (initial_request_ == NULL) {
    initial_request_ = new ::sarmata::InitialRecognizeRequest;
  }
  // @@protoc_insertion_point(field_mutable:sarmata.RecognizeRequest.initial_request)
  return initial_request_;
}
inline ::sarmata::InitialRecognizeRequest* RecognizeRequest::release_initial_request() {
  // @@protoc_insertion_point(field_release:sarmata.RecognizeRequest.initial_request)
  
  ::sarmata::InitialRecognizeRequest* temp = initial_request_;
  initial_request_ = NULL;
  return temp;
}
inline void RecognizeRequest::set_allocated_initial_request(::sarmata::InitialRecognizeRequest* initial_request) {
  delete initial_request_;
  initial_request_ = initial_request;
  if (initial_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:sarmata.RecognizeRequest.initial_request)
}

// optional .sarmata.AudioRequest audio_request = 2;
inline bool RecognizeRequest::has_audio_request() const {
  return !_is_default_instance_ && audio_request_ != NULL;
}
inline void RecognizeRequest::clear_audio_request() {
  if (GetArenaNoVirtual() == NULL && audio_request_ != NULL) delete audio_request_;
  audio_request_ = NULL;
}
inline const ::sarmata::AudioRequest& RecognizeRequest::audio_request() const {
  // @@protoc_insertion_point(field_get:sarmata.RecognizeRequest.audio_request)
  return audio_request_ != NULL ? *audio_request_ : *default_instance_->audio_request_;
}
inline ::sarmata::AudioRequest* RecognizeRequest::mutable_audio_request() {
  
  if (audio_request_ == NULL) {
    audio_request_ = new ::sarmata::AudioRequest;
  }
  // @@protoc_insertion_point(field_mutable:sarmata.RecognizeRequest.audio_request)
  return audio_request_;
}
inline ::sarmata::AudioRequest* RecognizeRequest::release_audio_request() {
  // @@protoc_insertion_point(field_release:sarmata.RecognizeRequest.audio_request)
  
  ::sarmata::AudioRequest* temp = audio_request_;
  audio_request_ = NULL;
  return temp;
}
inline void RecognizeRequest::set_allocated_audio_request(::sarmata::AudioRequest* audio_request) {
  delete audio_request_;
  audio_request_ = audio_request;
  if (audio_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:sarmata.RecognizeRequest.audio_request)
}

// -------------------------------------------------------------------

// ConfigField

// optional string key = 1;
inline void ConfigField::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConfigField::key() const {
  // @@protoc_insertion_point(field_get:sarmata.ConfigField.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigField::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.ConfigField.key)
}
inline void ConfigField::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.ConfigField.key)
}
inline void ConfigField::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.ConfigField.key)
}
inline ::std::string* ConfigField::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.ConfigField.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConfigField::release_key() {
  // @@protoc_insertion_point(field_release:sarmata.ConfigField.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigField::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:sarmata.ConfigField.key)
}

// optional string value = 2;
inline void ConfigField::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConfigField::value() const {
  // @@protoc_insertion_point(field_get:sarmata.ConfigField.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigField::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.ConfigField.value)
}
inline void ConfigField::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.ConfigField.value)
}
inline void ConfigField::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.ConfigField.value)
}
inline ::std::string* ConfigField::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.ConfigField.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConfigField::release_value() {
  // @@protoc_insertion_point(field_release:sarmata.ConfigField.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigField::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:sarmata.ConfigField.value)
}

// -------------------------------------------------------------------

// InitialRecognizeRequest

// repeated .sarmata.ConfigField config = 1;
inline int InitialRecognizeRequest::config_size() const {
  return config_.size();
}
inline void InitialRecognizeRequest::clear_config() {
  config_.Clear();
}
inline const ::sarmata::ConfigField& InitialRecognizeRequest::config(int index) const {
  // @@protoc_insertion_point(field_get:sarmata.InitialRecognizeRequest.config)
  return config_.Get(index);
}
inline ::sarmata::ConfigField* InitialRecognizeRequest::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:sarmata.InitialRecognizeRequest.config)
  return config_.Mutable(index);
}
inline ::sarmata::ConfigField* InitialRecognizeRequest::add_config() {
  // @@protoc_insertion_point(field_add:sarmata.InitialRecognizeRequest.config)
  return config_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::sarmata::ConfigField >*
InitialRecognizeRequest::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:sarmata.InitialRecognizeRequest.config)
  return &config_;
}
inline const ::google::protobuf::RepeatedPtrField< ::sarmata::ConfigField >&
InitialRecognizeRequest::config() const {
  // @@protoc_insertion_point(field_list:sarmata.InitialRecognizeRequest.config)
  return config_;
}

// optional string token = 2;
inline void InitialRecognizeRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InitialRecognizeRequest::token() const {
  // @@protoc_insertion_point(field_get:sarmata.InitialRecognizeRequest.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitialRecognizeRequest::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.InitialRecognizeRequest.token)
}
inline void InitialRecognizeRequest::set_token(const char* value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.InitialRecognizeRequest.token)
}
inline void InitialRecognizeRequest::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.InitialRecognizeRequest.token)
}
inline ::std::string* InitialRecognizeRequest::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.InitialRecognizeRequest.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitialRecognizeRequest::release_token() {
  // @@protoc_insertion_point(field_release:sarmata.InitialRecognizeRequest.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitialRecognizeRequest::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:sarmata.InitialRecognizeRequest.token)
}

// -------------------------------------------------------------------

// AudioRequest

// optional bytes content = 1;
inline void AudioRequest::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AudioRequest::content() const {
  // @@protoc_insertion_point(field_get:sarmata.AudioRequest.content)
  return content_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioRequest::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.AudioRequest.content)
}
inline void AudioRequest::set_content(const char* value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.AudioRequest.content)
}
inline void AudioRequest::set_content(const void* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.AudioRequest.content)
}
inline ::std::string* AudioRequest::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.AudioRequest.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AudioRequest::release_content() {
  // @@protoc_insertion_point(field_release:sarmata.AudioRequest.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioRequest::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:sarmata.AudioRequest.content)
}

// optional bool end_of_stream = 2;
inline void AudioRequest::clear_end_of_stream() {
  end_of_stream_ = false;
}
inline bool AudioRequest::end_of_stream() const {
  // @@protoc_insertion_point(field_get:sarmata.AudioRequest.end_of_stream)
  return end_of_stream_;
}
inline void AudioRequest::set_end_of_stream(bool value) {
  
  end_of_stream_ = value;
  // @@protoc_insertion_point(field_set:sarmata.AudioRequest.end_of_stream)
}

// -------------------------------------------------------------------

// InterpretRequest

// optional string token = 1;
inline void InterpretRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InterpretRequest::token() const {
  // @@protoc_insertion_point(field_get:sarmata.InterpretRequest.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InterpretRequest::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.InterpretRequest.token)
}
inline void InterpretRequest::set_token(const char* value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.InterpretRequest.token)
}
inline void InterpretRequest::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.InterpretRequest.token)
}
inline ::std::string* InterpretRequest::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.InterpretRequest.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InterpretRequest::release_token() {
  // @@protoc_insertion_point(field_release:sarmata.InterpretRequest.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InterpretRequest::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:sarmata.InterpretRequest.token)
}

// optional string grammar = 2;
inline void InterpretRequest::clear_grammar() {
  grammar_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InterpretRequest::grammar() const {
  // @@protoc_insertion_point(field_get:sarmata.InterpretRequest.grammar)
  return grammar_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InterpretRequest::set_grammar(const ::std::string& value) {
  
  grammar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.InterpretRequest.grammar)
}
inline void InterpretRequest::set_grammar(const char* value) {
  
  grammar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.InterpretRequest.grammar)
}
inline void InterpretRequest::set_grammar(const char* value, size_t size) {
  
  grammar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.InterpretRequest.grammar)
}
inline ::std::string* InterpretRequest::mutable_grammar() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.InterpretRequest.grammar)
  return grammar_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InterpretRequest::release_grammar() {
  // @@protoc_insertion_point(field_release:sarmata.InterpretRequest.grammar)
  
  return grammar_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InterpretRequest::set_allocated_grammar(::std::string* grammar) {
  if (grammar != NULL) {
    
  } else {
    
  }
  grammar_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), grammar);
  // @@protoc_insertion_point(field_set_allocated:sarmata.InterpretRequest.grammar)
}

// optional string sentence = 3;
inline void InterpretRequest::clear_sentence() {
  sentence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InterpretRequest::sentence() const {
  // @@protoc_insertion_point(field_get:sarmata.InterpretRequest.sentence)
  return sentence_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InterpretRequest::set_sentence(const ::std::string& value) {
  
  sentence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.InterpretRequest.sentence)
}
inline void InterpretRequest::set_sentence(const char* value) {
  
  sentence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.InterpretRequest.sentence)
}
inline void InterpretRequest::set_sentence(const char* value, size_t size) {
  
  sentence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.InterpretRequest.sentence)
}
inline ::std::string* InterpretRequest::mutable_sentence() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.InterpretRequest.sentence)
  return sentence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InterpretRequest::release_sentence() {
  // @@protoc_insertion_point(field_release:sarmata.InterpretRequest.sentence)
  
  return sentence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InterpretRequest::set_allocated_sentence(::std::string* sentence) {
  if (sentence != NULL) {
    
  } else {
    
  }
  sentence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sentence);
  // @@protoc_insertion_point(field_set_allocated:sarmata.InterpretRequest.sentence)
}

// -------------------------------------------------------------------

// InterpretResponse

// optional string error = 1;
inline void InterpretResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InterpretResponse::error() const {
  // @@protoc_insertion_point(field_get:sarmata.InterpretResponse.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InterpretResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.InterpretResponse.error)
}
inline void InterpretResponse::set_error(const char* value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.InterpretResponse.error)
}
inline void InterpretResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.InterpretResponse.error)
}
inline ::std::string* InterpretResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.InterpretResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InterpretResponse::release_error() {
  // @@protoc_insertion_point(field_release:sarmata.InterpretResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InterpretResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:sarmata.InterpretResponse.error)
}

// repeated string si = 2;
inline int InterpretResponse::si_size() const {
  return si_.size();
}
inline void InterpretResponse::clear_si() {
  si_.Clear();
}
inline const ::std::string& InterpretResponse::si(int index) const {
  // @@protoc_insertion_point(field_get:sarmata.InterpretResponse.si)
  return si_.Get(index);
}
inline ::std::string* InterpretResponse::mutable_si(int index) {
  // @@protoc_insertion_point(field_mutable:sarmata.InterpretResponse.si)
  return si_.Mutable(index);
}
inline void InterpretResponse::set_si(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:sarmata.InterpretResponse.si)
  si_.Mutable(index)->assign(value);
}
inline void InterpretResponse::set_si(int index, const char* value) {
  si_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sarmata.InterpretResponse.si)
}
inline void InterpretResponse::set_si(int index, const char* value, size_t size) {
  si_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sarmata.InterpretResponse.si)
}
inline ::std::string* InterpretResponse::add_si() {
  // @@protoc_insertion_point(field_add_mutable:sarmata.InterpretResponse.si)
  return si_.Add();
}
inline void InterpretResponse::add_si(const ::std::string& value) {
  si_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sarmata.InterpretResponse.si)
}
inline void InterpretResponse::add_si(const char* value) {
  si_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sarmata.InterpretResponse.si)
}
inline void InterpretResponse::add_si(const char* value, size_t size) {
  si_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sarmata.InterpretResponse.si)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InterpretResponse::si() const {
  // @@protoc_insertion_point(field_list:sarmata.InterpretResponse.si)
  return si_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InterpretResponse::mutable_si() {
  // @@protoc_insertion_point(field_mutable_list:sarmata.InterpretResponse.si)
  return &si_;
}

// -------------------------------------------------------------------

// DefineGrammarRequest

// optional string token = 1;
inline void DefineGrammarRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DefineGrammarRequest::token() const {
  // @@protoc_insertion_point(field_get:sarmata.DefineGrammarRequest.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarRequest::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.DefineGrammarRequest.token)
}
inline void DefineGrammarRequest::set_token(const char* value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.DefineGrammarRequest.token)
}
inline void DefineGrammarRequest::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.DefineGrammarRequest.token)
}
inline ::std::string* DefineGrammarRequest::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.DefineGrammarRequest.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DefineGrammarRequest::release_token() {
  // @@protoc_insertion_point(field_release:sarmata.DefineGrammarRequest.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarRequest::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:sarmata.DefineGrammarRequest.token)
}

// optional string name = 2;
inline void DefineGrammarRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DefineGrammarRequest::name() const {
  // @@protoc_insertion_point(field_get:sarmata.DefineGrammarRequest.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.DefineGrammarRequest.name)
}
inline void DefineGrammarRequest::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.DefineGrammarRequest.name)
}
inline void DefineGrammarRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.DefineGrammarRequest.name)
}
inline ::std::string* DefineGrammarRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.DefineGrammarRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DefineGrammarRequest::release_name() {
  // @@protoc_insertion_point(field_release:sarmata.DefineGrammarRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:sarmata.DefineGrammarRequest.name)
}

// optional string grammar = 3;
inline void DefineGrammarRequest::clear_grammar() {
  grammar_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DefineGrammarRequest::grammar() const {
  // @@protoc_insertion_point(field_get:sarmata.DefineGrammarRequest.grammar)
  return grammar_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarRequest::set_grammar(const ::std::string& value) {
  
  grammar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.DefineGrammarRequest.grammar)
}
inline void DefineGrammarRequest::set_grammar(const char* value) {
  
  grammar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.DefineGrammarRequest.grammar)
}
inline void DefineGrammarRequest::set_grammar(const char* value, size_t size) {
  
  grammar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.DefineGrammarRequest.grammar)
}
inline ::std::string* DefineGrammarRequest::mutable_grammar() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.DefineGrammarRequest.grammar)
  return grammar_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DefineGrammarRequest::release_grammar() {
  // @@protoc_insertion_point(field_release:sarmata.DefineGrammarRequest.grammar)
  
  return grammar_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarRequest::set_allocated_grammar(::std::string* grammar) {
  if (grammar != NULL) {
    
  } else {
    
  }
  grammar_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), grammar);
  // @@protoc_insertion_point(field_set_allocated:sarmata.DefineGrammarRequest.grammar)
}

// -------------------------------------------------------------------

// DefineGrammarRespone

// optional string error = 1;
inline void DefineGrammarRespone::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DefineGrammarRespone::error() const {
  // @@protoc_insertion_point(field_get:sarmata.DefineGrammarRespone.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarRespone::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.DefineGrammarRespone.error)
}
inline void DefineGrammarRespone::set_error(const char* value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.DefineGrammarRespone.error)
}
inline void DefineGrammarRespone::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.DefineGrammarRespone.error)
}
inline ::std::string* DefineGrammarRespone::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.DefineGrammarRespone.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DefineGrammarRespone::release_error() {
  // @@protoc_insertion_point(field_release:sarmata.DefineGrammarRespone.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarRespone::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:sarmata.DefineGrammarRespone.error)
}

// optional string grammarName = 2;
inline void DefineGrammarRespone::clear_grammarname() {
  grammarname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DefineGrammarRespone::grammarname() const {
  // @@protoc_insertion_point(field_get:sarmata.DefineGrammarRespone.grammarName)
  return grammarname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarRespone::set_grammarname(const ::std::string& value) {
  
  grammarname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.DefineGrammarRespone.grammarName)
}
inline void DefineGrammarRespone::set_grammarname(const char* value) {
  
  grammarname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.DefineGrammarRespone.grammarName)
}
inline void DefineGrammarRespone::set_grammarname(const char* value, size_t size) {
  
  grammarname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.DefineGrammarRespone.grammarName)
}
inline ::std::string* DefineGrammarRespone::mutable_grammarname() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.DefineGrammarRespone.grammarName)
  return grammarname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DefineGrammarRespone::release_grammarname() {
  // @@protoc_insertion_point(field_release:sarmata.DefineGrammarRespone.grammarName)
  
  return grammarname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarRespone::set_allocated_grammarname(::std::string* grammarname) {
  if (grammarname != NULL) {
    
  } else {
    
  }
  grammarname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), grammarname);
  // @@protoc_insertion_point(field_set_allocated:sarmata.DefineGrammarRespone.grammarName)
}

// -------------------------------------------------------------------

// RecognizeResponse

// optional .sarmata.ResponseStatus status = 1;
inline void RecognizeResponse::clear_status() {
  status_ = 0;
}
inline ::sarmata::ResponseStatus RecognizeResponse::status() const {
  // @@protoc_insertion_point(field_get:sarmata.RecognizeResponse.status)
  return static_cast< ::sarmata::ResponseStatus >(status_);
}
inline void RecognizeResponse::set_status(::sarmata::ResponseStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:sarmata.RecognizeResponse.status)
}

// optional string error = 2;
inline void RecognizeResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecognizeResponse::error() const {
  // @@protoc_insertion_point(field_get:sarmata.RecognizeResponse.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizeResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.RecognizeResponse.error)
}
inline void RecognizeResponse::set_error(const char* value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.RecognizeResponse.error)
}
inline void RecognizeResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.RecognizeResponse.error)
}
inline ::std::string* RecognizeResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.RecognizeResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecognizeResponse::release_error() {
  // @@protoc_insertion_point(field_release:sarmata.RecognizeResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizeResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:sarmata.RecognizeResponse.error)
}

// optional string warning = 3;
inline void RecognizeResponse::clear_warning() {
  warning_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecognizeResponse::warning() const {
  // @@protoc_insertion_point(field_get:sarmata.RecognizeResponse.warning)
  return warning_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizeResponse::set_warning(const ::std::string& value) {
  
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.RecognizeResponse.warning)
}
inline void RecognizeResponse::set_warning(const char* value) {
  
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.RecognizeResponse.warning)
}
inline void RecognizeResponse::set_warning(const char* value, size_t size) {
  
  warning_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.RecognizeResponse.warning)
}
inline ::std::string* RecognizeResponse::mutable_warning() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.RecognizeResponse.warning)
  return warning_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecognizeResponse::release_warning() {
  // @@protoc_insertion_point(field_release:sarmata.RecognizeResponse.warning)
  
  return warning_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizeResponse::set_allocated_warning(::std::string* warning) {
  if (warning != NULL) {
    
  } else {
    
  }
  warning_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), warning);
  // @@protoc_insertion_point(field_set_allocated:sarmata.RecognizeResponse.warning)
}

// optional int32 event_time = 4;
inline void RecognizeResponse::clear_event_time() {
  event_time_ = 0;
}
inline ::google::protobuf::int32 RecognizeResponse::event_time() const {
  // @@protoc_insertion_point(field_get:sarmata.RecognizeResponse.event_time)
  return event_time_;
}
inline void RecognizeResponse::set_event_time(::google::protobuf::int32 value) {
  
  event_time_ = value;
  // @@protoc_insertion_point(field_set:sarmata.RecognizeResponse.event_time)
}

// repeated .sarmata.Phrase results = 5;
inline int RecognizeResponse::results_size() const {
  return results_.size();
}
inline void RecognizeResponse::clear_results() {
  results_.Clear();
}
inline const ::sarmata::Phrase& RecognizeResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:sarmata.RecognizeResponse.results)
  return results_.Get(index);
}
inline ::sarmata::Phrase* RecognizeResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:sarmata.RecognizeResponse.results)
  return results_.Mutable(index);
}
inline ::sarmata::Phrase* RecognizeResponse::add_results() {
  // @@protoc_insertion_point(field_add:sarmata.RecognizeResponse.results)
  return results_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::sarmata::Phrase >*
RecognizeResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:sarmata.RecognizeResponse.results)
  return &results_;
}
inline const ::google::protobuf::RepeatedPtrField< ::sarmata::Phrase >&
RecognizeResponse::results() const {
  // @@protoc_insertion_point(field_list:sarmata.RecognizeResponse.results)
  return results_;
}

// -------------------------------------------------------------------

// Phrase_Word

// optional string transcript = 1;
inline void Phrase_Word::clear_transcript() {
  transcript_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Phrase_Word::transcript() const {
  // @@protoc_insertion_point(field_get:sarmata.Phrase.Word.transcript)
  return transcript_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Phrase_Word::set_transcript(const ::std::string& value) {
  
  transcript_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.Phrase.Word.transcript)
}
inline void Phrase_Word::set_transcript(const char* value) {
  
  transcript_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.Phrase.Word.transcript)
}
inline void Phrase_Word::set_transcript(const char* value, size_t size) {
  
  transcript_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.Phrase.Word.transcript)
}
inline ::std::string* Phrase_Word::mutable_transcript() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.Phrase.Word.transcript)
  return transcript_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Phrase_Word::release_transcript() {
  // @@protoc_insertion_point(field_release:sarmata.Phrase.Word.transcript)
  
  return transcript_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Phrase_Word::set_allocated_transcript(::std::string* transcript) {
  if (transcript != NULL) {
    
  } else {
    
  }
  transcript_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transcript);
  // @@protoc_insertion_point(field_set_allocated:sarmata.Phrase.Word.transcript)
}

// optional double confidence = 2;
inline void Phrase_Word::clear_confidence() {
  confidence_ = 0;
}
inline double Phrase_Word::confidence() const {
  // @@protoc_insertion_point(field_get:sarmata.Phrase.Word.confidence)
  return confidence_;
}
inline void Phrase_Word::set_confidence(double value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:sarmata.Phrase.Word.confidence)
}

// optional int32 start = 3;
inline void Phrase_Word::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 Phrase_Word::start() const {
  // @@protoc_insertion_point(field_get:sarmata.Phrase.Word.start)
  return start_;
}
inline void Phrase_Word::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:sarmata.Phrase.Word.start)
}

// optional int32 end = 4;
inline void Phrase_Word::clear_end() {
  end_ = 0;
}
inline ::google::protobuf::int32 Phrase_Word::end() const {
  // @@protoc_insertion_point(field_get:sarmata.Phrase.Word.end)
  return end_;
}
inline void Phrase_Word::set_end(::google::protobuf::int32 value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:sarmata.Phrase.Word.end)
}

// optional double logprob = 5;
inline void Phrase_Word::clear_logprob() {
  logprob_ = 0;
}
inline double Phrase_Word::logprob() const {
  // @@protoc_insertion_point(field_get:sarmata.Phrase.Word.logprob)
  return logprob_;
}
inline void Phrase_Word::set_logprob(double value) {
  
  logprob_ = value;
  // @@protoc_insertion_point(field_set:sarmata.Phrase.Word.logprob)
}

// -------------------------------------------------------------------

// Phrase

// repeated .sarmata.Phrase.Word words = 1;
inline int Phrase::words_size() const {
  return words_.size();
}
inline void Phrase::clear_words() {
  words_.Clear();
}
inline const ::sarmata::Phrase_Word& Phrase::words(int index) const {
  // @@protoc_insertion_point(field_get:sarmata.Phrase.words)
  return words_.Get(index);
}
inline ::sarmata::Phrase_Word* Phrase::mutable_words(int index) {
  // @@protoc_insertion_point(field_mutable:sarmata.Phrase.words)
  return words_.Mutable(index);
}
inline ::sarmata::Phrase_Word* Phrase::add_words() {
  // @@protoc_insertion_point(field_add:sarmata.Phrase.words)
  return words_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::sarmata::Phrase_Word >*
Phrase::mutable_words() {
  // @@protoc_insertion_point(field_mutable_list:sarmata.Phrase.words)
  return &words_;
}
inline const ::google::protobuf::RepeatedPtrField< ::sarmata::Phrase_Word >&
Phrase::words() const {
  // @@protoc_insertion_point(field_list:sarmata.Phrase.words)
  return words_;
}

// optional double confidence = 2;
inline void Phrase::clear_confidence() {
  confidence_ = 0;
}
inline double Phrase::confidence() const {
  // @@protoc_insertion_point(field_get:sarmata.Phrase.confidence)
  return confidence_;
}
inline void Phrase::set_confidence(double value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:sarmata.Phrase.confidence)
}

// optional bool correct = 3;
inline void Phrase::clear_correct() {
  correct_ = false;
}
inline bool Phrase::correct() const {
  // @@protoc_insertion_point(field_get:sarmata.Phrase.correct)
  return correct_;
}
inline void Phrase::set_correct(bool value) {
  
  correct_ = value;
  // @@protoc_insertion_point(field_set:sarmata.Phrase.correct)
}

// optional string semantic_interpretation = 4;
inline void Phrase::clear_semantic_interpretation() {
  semantic_interpretation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Phrase::semantic_interpretation() const {
  // @@protoc_insertion_point(field_get:sarmata.Phrase.semantic_interpretation)
  return semantic_interpretation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Phrase::set_semantic_interpretation(const ::std::string& value) {
  
  semantic_interpretation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sarmata.Phrase.semantic_interpretation)
}
inline void Phrase::set_semantic_interpretation(const char* value) {
  
  semantic_interpretation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sarmata.Phrase.semantic_interpretation)
}
inline void Phrase::set_semantic_interpretation(const char* value, size_t size) {
  
  semantic_interpretation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sarmata.Phrase.semantic_interpretation)
}
inline ::std::string* Phrase::mutable_semantic_interpretation() {
  
  // @@protoc_insertion_point(field_mutable:sarmata.Phrase.semantic_interpretation)
  return semantic_interpretation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Phrase::release_semantic_interpretation() {
  // @@protoc_insertion_point(field_release:sarmata.Phrase.semantic_interpretation)
  
  return semantic_interpretation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Phrase::set_allocated_semantic_interpretation(::std::string* semantic_interpretation) {
  if (semantic_interpretation != NULL) {
    
  } else {
    
  }
  semantic_interpretation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), semantic_interpretation);
  // @@protoc_insertion_point(field_set_allocated:sarmata.Phrase.semantic_interpretation)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sarmata

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sarmata::ResponseStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sarmata::ResponseStatus>() {
  return ::sarmata::ResponseStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_asr_5fservice_2eproto__INCLUDED
