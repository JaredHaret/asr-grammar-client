// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sarmata_asr.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sarmata_5fasr_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sarmata_5fasr_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sarmata_5fasr_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sarmata_5fasr_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sarmata_5fasr_2eproto;
namespace techmo {
namespace sarmata {
class ConfigField;
class ConfigFieldDefaultTypeInternal;
extern ConfigFieldDefaultTypeInternal _ConfigField_default_instance_;
class DefineGrammarRequest;
class DefineGrammarRequestDefaultTypeInternal;
extern DefineGrammarRequestDefaultTypeInternal _DefineGrammarRequest_default_instance_;
class DefineGrammarResponse;
class DefineGrammarResponseDefaultTypeInternal;
extern DefineGrammarResponseDefaultTypeInternal _DefineGrammarResponse_default_instance_;
class RecognitionConfig;
class RecognitionConfigDefaultTypeInternal;
extern RecognitionConfigDefaultTypeInternal _RecognitionConfig_default_instance_;
class RecognizeRequest;
class RecognizeRequestDefaultTypeInternal;
extern RecognizeRequestDefaultTypeInternal _RecognizeRequest_default_instance_;
class RecognizeResponse;
class RecognizeResponseDefaultTypeInternal;
extern RecognizeResponseDefaultTypeInternal _RecognizeResponse_default_instance_;
class RecognizedPhrase;
class RecognizedPhraseDefaultTypeInternal;
extern RecognizedPhraseDefaultTypeInternal _RecognizedPhrase_default_instance_;
class RecognizedPhrase_RecognizedWord;
class RecognizedPhrase_RecognizedWordDefaultTypeInternal;
extern RecognizedPhrase_RecognizedWordDefaultTypeInternal _RecognizedPhrase_RecognizedWord_default_instance_;
class TimeoutSettings;
class TimeoutSettingsDefaultTypeInternal;
extern TimeoutSettingsDefaultTypeInternal _TimeoutSettings_default_instance_;
}  // namespace sarmata
}  // namespace techmo
PROTOBUF_NAMESPACE_OPEN
template<> ::techmo::sarmata::ConfigField* Arena::CreateMaybeMessage<::techmo::sarmata::ConfigField>(Arena*);
template<> ::techmo::sarmata::DefineGrammarRequest* Arena::CreateMaybeMessage<::techmo::sarmata::DefineGrammarRequest>(Arena*);
template<> ::techmo::sarmata::DefineGrammarResponse* Arena::CreateMaybeMessage<::techmo::sarmata::DefineGrammarResponse>(Arena*);
template<> ::techmo::sarmata::RecognitionConfig* Arena::CreateMaybeMessage<::techmo::sarmata::RecognitionConfig>(Arena*);
template<> ::techmo::sarmata::RecognizeRequest* Arena::CreateMaybeMessage<::techmo::sarmata::RecognizeRequest>(Arena*);
template<> ::techmo::sarmata::RecognizeResponse* Arena::CreateMaybeMessage<::techmo::sarmata::RecognizeResponse>(Arena*);
template<> ::techmo::sarmata::RecognizedPhrase* Arena::CreateMaybeMessage<::techmo::sarmata::RecognizedPhrase>(Arena*);
template<> ::techmo::sarmata::RecognizedPhrase_RecognizedWord* Arena::CreateMaybeMessage<::techmo::sarmata::RecognizedPhrase_RecognizedWord>(Arena*);
template<> ::techmo::sarmata::TimeoutSettings* Arena::CreateMaybeMessage<::techmo::sarmata::TimeoutSettings>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace techmo {
namespace sarmata {

enum ResponseStatus : int {
  EMPTY = 0,
  SUCCESS = 1,
  PARTIAL_MATCH = 2,
  NO_MATCH = 3,
  NO_INPUT_TIMEOUT = 4,
  GRAMMAR_LOAD_FAILURE = 5,
  GRAMMAR_COMPILATION_FAILURE = 6,
  RECOGNIZER_ERROR = 7,
  TOO_MUCH_SPEECH_TIMEOUT = 8,
  CANCELLED = 9,
  START_OF_INPUT = 10,
  END_OF_AUDIO = 11,
  SEMANTICS_FAILURE = 12,
  ResponseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResponseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResponseStatus_IsValid(int value);
constexpr ResponseStatus ResponseStatus_MIN = EMPTY;
constexpr ResponseStatus ResponseStatus_MAX = SEMANTICS_FAILURE;
constexpr int ResponseStatus_ARRAYSIZE = ResponseStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseStatus_descriptor();
template<typename T>
inline const std::string& ResponseStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseStatus_descriptor(), enum_t_value);
}
inline bool ResponseStatus_Parse(
    const std::string& name, ResponseStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseStatus>(
    ResponseStatus_descriptor(), name, value);
}
// ===================================================================

class RecognizeRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:techmo.sarmata.RecognizeRequest) */ {
 public:
  RecognizeRequest();
  virtual ~RecognizeRequest();

  RecognizeRequest(const RecognizeRequest& from);
  RecognizeRequest(RecognizeRequest&& from) noexcept
    : RecognizeRequest() {
    *this = ::std::move(from);
  }

  inline RecognizeRequest& operator=(const RecognizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecognizeRequest& operator=(RecognizeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecognizeRequest& default_instance();

  enum RequestCase {
    kConfig = 1,
    kAudioContent = 2,
    REQUEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecognizeRequest* internal_default_instance() {
    return reinterpret_cast<const RecognizeRequest*>(
               &_RecognizeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RecognizeRequest* other);
  friend void swap(RecognizeRequest& a, RecognizeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecognizeRequest* New() const final {
    return CreateMaybeMessage<RecognizeRequest>(nullptr);
  }

  RecognizeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecognizeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecognizeRequest& from);
  void MergeFrom(const RecognizeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecognizeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "techmo.sarmata.RecognizeRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sarmata_5fasr_2eproto);
    return ::descriptor_table_sarmata_5fasr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .techmo.sarmata.RecognitionConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::techmo::sarmata::RecognitionConfig& config() const;
  ::techmo::sarmata::RecognitionConfig* release_config();
  ::techmo::sarmata::RecognitionConfig* mutable_config();
  void set_allocated_config(::techmo::sarmata::RecognitionConfig* config);

  // bytes audio_content = 2;
  private:
  bool has_audio_content() const;
  public:
  void clear_audio_content();
  static const int kAudioContentFieldNumber = 2;
  const std::string& audio_content() const;
  void set_audio_content(const std::string& value);
  void set_audio_content(std::string&& value);
  void set_audio_content(const char* value);
  void set_audio_content(const void* value, size_t size);
  std::string* mutable_audio_content();
  std::string* release_audio_content();
  void set_allocated_audio_content(std::string* audio_content);

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:techmo.sarmata.RecognizeRequest)
 private:
  class HasBitSetters;
  void set_has_config();
  void set_has_audio_content();

  inline bool has_request() const;
  inline void clear_has_request();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union RequestUnion {
    RequestUnion() {}
    ::techmo::sarmata::RecognitionConfig* config_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_content_;
  } request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_sarmata_5fasr_2eproto;
};
// -------------------------------------------------------------------

class RecognitionConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:techmo.sarmata.RecognitionConfig) */ {
 public:
  RecognitionConfig();
  virtual ~RecognitionConfig();

  RecognitionConfig(const RecognitionConfig& from);
  RecognitionConfig(RecognitionConfig&& from) noexcept
    : RecognitionConfig() {
    *this = ::std::move(from);
  }

  inline RecognitionConfig& operator=(const RecognitionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecognitionConfig& operator=(RecognitionConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecognitionConfig& default_instance();

  enum GrammarCase {
    kGrammarName = 1,
    kGrammarData = 2,
    GRAMMAR_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecognitionConfig* internal_default_instance() {
    return reinterpret_cast<const RecognitionConfig*>(
               &_RecognitionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RecognitionConfig* other);
  friend void swap(RecognitionConfig& a, RecognitionConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecognitionConfig* New() const final {
    return CreateMaybeMessage<RecognitionConfig>(nullptr);
  }

  RecognitionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecognitionConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecognitionConfig& from);
  void MergeFrom(const RecognitionConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecognitionConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "techmo.sarmata.RecognitionConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sarmata_5fasr_2eproto);
    return ::descriptor_table_sarmata_5fasr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .techmo.sarmata.ConfigField additional_settings = 7;
  int additional_settings_size() const;
  void clear_additional_settings();
  static const int kAdditionalSettingsFieldNumber = 7;
  ::techmo::sarmata::ConfigField* mutable_additional_settings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::ConfigField >*
      mutable_additional_settings();
  const ::techmo::sarmata::ConfigField& additional_settings(int index) const;
  ::techmo::sarmata::ConfigField* add_additional_settings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::ConfigField >&
      additional_settings() const;

  // .techmo.sarmata.TimeoutSettings timeout_settings = 6;
  bool has_timeout_settings() const;
  void clear_timeout_settings();
  static const int kTimeoutSettingsFieldNumber = 6;
  const ::techmo::sarmata::TimeoutSettings& timeout_settings() const;
  ::techmo::sarmata::TimeoutSettings* release_timeout_settings();
  ::techmo::sarmata::TimeoutSettings* mutable_timeout_settings();
  void set_allocated_timeout_settings(::techmo::sarmata::TimeoutSettings* timeout_settings);

  // int32 sample_rate_hertz = 3;
  void clear_sample_rate_hertz();
  static const int kSampleRateHertzFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 sample_rate_hertz() const;
  void set_sample_rate_hertz(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 max_alternatives = 4;
  void clear_max_alternatives();
  static const int kMaxAlternativesFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 max_alternatives() const;
  void set_max_alternatives(::PROTOBUF_NAMESPACE_ID::int32 value);

  // double no_match_threshold = 5;
  void clear_no_match_threshold();
  static const int kNoMatchThresholdFieldNumber = 5;
  double no_match_threshold() const;
  void set_no_match_threshold(double value);

  // string grammar_name = 1;
  private:
  bool has_grammar_name() const;
  public:
  void clear_grammar_name();
  static const int kGrammarNameFieldNumber = 1;
  const std::string& grammar_name() const;
  void set_grammar_name(const std::string& value);
  void set_grammar_name(std::string&& value);
  void set_grammar_name(const char* value);
  void set_grammar_name(const char* value, size_t size);
  std::string* mutable_grammar_name();
  std::string* release_grammar_name();
  void set_allocated_grammar_name(std::string* grammar_name);

  // string grammar_data = 2;
  private:
  bool has_grammar_data() const;
  public:
  void clear_grammar_data();
  static const int kGrammarDataFieldNumber = 2;
  const std::string& grammar_data() const;
  void set_grammar_data(const std::string& value);
  void set_grammar_data(std::string&& value);
  void set_grammar_data(const char* value);
  void set_grammar_data(const char* value, size_t size);
  std::string* mutable_grammar_data();
  std::string* release_grammar_data();
  void set_allocated_grammar_data(std::string* grammar_data);

  void clear_grammar();
  GrammarCase grammar_case() const;
  // @@protoc_insertion_point(class_scope:techmo.sarmata.RecognitionConfig)
 private:
  class HasBitSetters;
  void set_has_grammar_name();
  void set_has_grammar_data();

  inline bool has_grammar() const;
  inline void clear_has_grammar();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::ConfigField > additional_settings_;
  ::techmo::sarmata::TimeoutSettings* timeout_settings_;
  ::PROTOBUF_NAMESPACE_ID::int32 sample_rate_hertz_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_alternatives_;
  double no_match_threshold_;
  union GrammarUnion {
    GrammarUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr grammar_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr grammar_data_;
  } grammar_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_sarmata_5fasr_2eproto;
};
// -------------------------------------------------------------------

class TimeoutSettings :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:techmo.sarmata.TimeoutSettings) */ {
 public:
  TimeoutSettings();
  virtual ~TimeoutSettings();

  TimeoutSettings(const TimeoutSettings& from);
  TimeoutSettings(TimeoutSettings&& from) noexcept
    : TimeoutSettings() {
    *this = ::std::move(from);
  }

  inline TimeoutSettings& operator=(const TimeoutSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeoutSettings& operator=(TimeoutSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TimeoutSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeoutSettings* internal_default_instance() {
    return reinterpret_cast<const TimeoutSettings*>(
               &_TimeoutSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TimeoutSettings* other);
  friend void swap(TimeoutSettings& a, TimeoutSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeoutSettings* New() const final {
    return CreateMaybeMessage<TimeoutSettings>(nullptr);
  }

  TimeoutSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimeoutSettings>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimeoutSettings& from);
  void MergeFrom(const TimeoutSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeoutSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "techmo.sarmata.TimeoutSettings";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sarmata_5fasr_2eproto);
    return ::descriptor_table_sarmata_5fasr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 no_input_timeout = 1;
  void clear_no_input_timeout();
  static const int kNoInputTimeoutFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 no_input_timeout() const;
  void set_no_input_timeout(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 recognition_timeout = 2;
  void clear_recognition_timeout();
  static const int kRecognitionTimeoutFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 recognition_timeout() const;
  void set_recognition_timeout(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 speech_complete_timeout = 3;
  void clear_speech_complete_timeout();
  static const int kSpeechCompleteTimeoutFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 speech_complete_timeout() const;
  void set_speech_complete_timeout(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 speech_incomplete_timeout = 4;
  void clear_speech_incomplete_timeout();
  static const int kSpeechIncompleteTimeoutFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 speech_incomplete_timeout() const;
  void set_speech_incomplete_timeout(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:techmo.sarmata.TimeoutSettings)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 no_input_timeout_;
  ::PROTOBUF_NAMESPACE_ID::int32 recognition_timeout_;
  ::PROTOBUF_NAMESPACE_ID::int32 speech_complete_timeout_;
  ::PROTOBUF_NAMESPACE_ID::int32 speech_incomplete_timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sarmata_5fasr_2eproto;
};
// -------------------------------------------------------------------

class ConfigField :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:techmo.sarmata.ConfigField) */ {
 public:
  ConfigField();
  virtual ~ConfigField();

  ConfigField(const ConfigField& from);
  ConfigField(ConfigField&& from) noexcept
    : ConfigField() {
    *this = ::std::move(from);
  }

  inline ConfigField& operator=(const ConfigField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigField& operator=(ConfigField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConfigField& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigField* internal_default_instance() {
    return reinterpret_cast<const ConfigField*>(
               &_ConfigField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ConfigField* other);
  friend void swap(ConfigField& a, ConfigField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigField* New() const final {
    return CreateMaybeMessage<ConfigField>(nullptr);
  }

  ConfigField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConfigField>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConfigField& from);
  void MergeFrom(const ConfigField& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigField* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "techmo.sarmata.ConfigField";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sarmata_5fasr_2eproto);
    return ::descriptor_table_sarmata_5fasr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:techmo.sarmata.ConfigField)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sarmata_5fasr_2eproto;
};
// -------------------------------------------------------------------

class RecognizeResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:techmo.sarmata.RecognizeResponse) */ {
 public:
  RecognizeResponse();
  virtual ~RecognizeResponse();

  RecognizeResponse(const RecognizeResponse& from);
  RecognizeResponse(RecognizeResponse&& from) noexcept
    : RecognizeResponse() {
    *this = ::std::move(from);
  }

  inline RecognizeResponse& operator=(const RecognizeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecognizeResponse& operator=(RecognizeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecognizeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecognizeResponse* internal_default_instance() {
    return reinterpret_cast<const RecognizeResponse*>(
               &_RecognizeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RecognizeResponse* other);
  friend void swap(RecognizeResponse& a, RecognizeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecognizeResponse* New() const final {
    return CreateMaybeMessage<RecognizeResponse>(nullptr);
  }

  RecognizeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecognizeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecognizeResponse& from);
  void MergeFrom(const RecognizeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecognizeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "techmo.sarmata.RecognizeResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sarmata_5fasr_2eproto);
    return ::descriptor_table_sarmata_5fasr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .techmo.sarmata.RecognizedPhrase results = 4;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 4;
  ::techmo::sarmata::RecognizedPhrase* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::RecognizedPhrase >*
      mutable_results();
  const ::techmo::sarmata::RecognizedPhrase& results(int index) const;
  ::techmo::sarmata::RecognizedPhrase* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::RecognizedPhrase >&
      results() const;

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);

  // .techmo.sarmata.ResponseStatus status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::techmo::sarmata::ResponseStatus status() const;
  void set_status(::techmo::sarmata::ResponseStatus value);

  // int32 event_time = 3;
  void clear_event_time();
  static const int kEventTimeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 event_time() const;
  void set_event_time(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:techmo.sarmata.RecognizeResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::RecognizedPhrase > results_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::int32 event_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sarmata_5fasr_2eproto;
};
// -------------------------------------------------------------------

class RecognizedPhrase_RecognizedWord :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:techmo.sarmata.RecognizedPhrase.RecognizedWord) */ {
 public:
  RecognizedPhrase_RecognizedWord();
  virtual ~RecognizedPhrase_RecognizedWord();

  RecognizedPhrase_RecognizedWord(const RecognizedPhrase_RecognizedWord& from);
  RecognizedPhrase_RecognizedWord(RecognizedPhrase_RecognizedWord&& from) noexcept
    : RecognizedPhrase_RecognizedWord() {
    *this = ::std::move(from);
  }

  inline RecognizedPhrase_RecognizedWord& operator=(const RecognizedPhrase_RecognizedWord& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecognizedPhrase_RecognizedWord& operator=(RecognizedPhrase_RecognizedWord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecognizedPhrase_RecognizedWord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecognizedPhrase_RecognizedWord* internal_default_instance() {
    return reinterpret_cast<const RecognizedPhrase_RecognizedWord*>(
               &_RecognizedPhrase_RecognizedWord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RecognizedPhrase_RecognizedWord* other);
  friend void swap(RecognizedPhrase_RecognizedWord& a, RecognizedPhrase_RecognizedWord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecognizedPhrase_RecognizedWord* New() const final {
    return CreateMaybeMessage<RecognizedPhrase_RecognizedWord>(nullptr);
  }

  RecognizedPhrase_RecognizedWord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecognizedPhrase_RecognizedWord>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecognizedPhrase_RecognizedWord& from);
  void MergeFrom(const RecognizedPhrase_RecognizedWord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecognizedPhrase_RecognizedWord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "techmo.sarmata.RecognizedPhrase.RecognizedWord";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sarmata_5fasr_2eproto);
    return ::descriptor_table_sarmata_5fasr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string transcript = 1;
  void clear_transcript();
  static const int kTranscriptFieldNumber = 1;
  const std::string& transcript() const;
  void set_transcript(const std::string& value);
  void set_transcript(std::string&& value);
  void set_transcript(const char* value);
  void set_transcript(const char* value, size_t size);
  std::string* mutable_transcript();
  std::string* release_transcript();
  void set_allocated_transcript(std::string* transcript);

  // double confidence = 2;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  double confidence() const;
  void set_confidence(double value);

  // int32 start = 3;
  void clear_start();
  static const int kStartFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 end = 4;
  void clear_end();
  static const int kEndFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);

  // double logprob = 5;
  void clear_logprob();
  static const int kLogprobFieldNumber = 5;
  double logprob() const;
  void set_logprob(double value);

  // @@protoc_insertion_point(class_scope:techmo.sarmata.RecognizedPhrase.RecognizedWord)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transcript_;
  double confidence_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  double logprob_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sarmata_5fasr_2eproto;
};
// -------------------------------------------------------------------

class RecognizedPhrase :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:techmo.sarmata.RecognizedPhrase) */ {
 public:
  RecognizedPhrase();
  virtual ~RecognizedPhrase();

  RecognizedPhrase(const RecognizedPhrase& from);
  RecognizedPhrase(RecognizedPhrase&& from) noexcept
    : RecognizedPhrase() {
    *this = ::std::move(from);
  }

  inline RecognizedPhrase& operator=(const RecognizedPhrase& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecognizedPhrase& operator=(RecognizedPhrase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecognizedPhrase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecognizedPhrase* internal_default_instance() {
    return reinterpret_cast<const RecognizedPhrase*>(
               &_RecognizedPhrase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RecognizedPhrase* other);
  friend void swap(RecognizedPhrase& a, RecognizedPhrase& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecognizedPhrase* New() const final {
    return CreateMaybeMessage<RecognizedPhrase>(nullptr);
  }

  RecognizedPhrase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecognizedPhrase>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecognizedPhrase& from);
  void MergeFrom(const RecognizedPhrase& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecognizedPhrase* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "techmo.sarmata.RecognizedPhrase";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sarmata_5fasr_2eproto);
    return ::descriptor_table_sarmata_5fasr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RecognizedPhrase_RecognizedWord RecognizedWord;

  // accessors -------------------------------------------------------

  // repeated .techmo.sarmata.RecognizedPhrase.RecognizedWord words = 1;
  int words_size() const;
  void clear_words();
  static const int kWordsFieldNumber = 1;
  ::techmo::sarmata::RecognizedPhrase_RecognizedWord* mutable_words(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::RecognizedPhrase_RecognizedWord >*
      mutable_words();
  const ::techmo::sarmata::RecognizedPhrase_RecognizedWord& words(int index) const;
  ::techmo::sarmata::RecognizedPhrase_RecognizedWord* add_words();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::RecognizedPhrase_RecognizedWord >&
      words() const;

  // string semantic_interpretation = 4;
  void clear_semantic_interpretation();
  static const int kSemanticInterpretationFieldNumber = 4;
  const std::string& semantic_interpretation() const;
  void set_semantic_interpretation(const std::string& value);
  void set_semantic_interpretation(std::string&& value);
  void set_semantic_interpretation(const char* value);
  void set_semantic_interpretation(const char* value, size_t size);
  std::string* mutable_semantic_interpretation();
  std::string* release_semantic_interpretation();
  void set_allocated_semantic_interpretation(std::string* semantic_interpretation);

  // double confidence = 2;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  double confidence() const;
  void set_confidence(double value);

  // bool correct = 3;
  void clear_correct();
  static const int kCorrectFieldNumber = 3;
  bool correct() const;
  void set_correct(bool value);

  // @@protoc_insertion_point(class_scope:techmo.sarmata.RecognizedPhrase)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::RecognizedPhrase_RecognizedWord > words_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr semantic_interpretation_;
  double confidence_;
  bool correct_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sarmata_5fasr_2eproto;
};
// -------------------------------------------------------------------

class DefineGrammarRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:techmo.sarmata.DefineGrammarRequest) */ {
 public:
  DefineGrammarRequest();
  virtual ~DefineGrammarRequest();

  DefineGrammarRequest(const DefineGrammarRequest& from);
  DefineGrammarRequest(DefineGrammarRequest&& from) noexcept
    : DefineGrammarRequest() {
    *this = ::std::move(from);
  }

  inline DefineGrammarRequest& operator=(const DefineGrammarRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefineGrammarRequest& operator=(DefineGrammarRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DefineGrammarRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DefineGrammarRequest* internal_default_instance() {
    return reinterpret_cast<const DefineGrammarRequest*>(
               &_DefineGrammarRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DefineGrammarRequest* other);
  friend void swap(DefineGrammarRequest& a, DefineGrammarRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DefineGrammarRequest* New() const final {
    return CreateMaybeMessage<DefineGrammarRequest>(nullptr);
  }

  DefineGrammarRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DefineGrammarRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DefineGrammarRequest& from);
  void MergeFrom(const DefineGrammarRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefineGrammarRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "techmo.sarmata.DefineGrammarRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sarmata_5fasr_2eproto);
    return ::descriptor_table_sarmata_5fasr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string grammar_name = 1;
  void clear_grammar_name();
  static const int kGrammarNameFieldNumber = 1;
  const std::string& grammar_name() const;
  void set_grammar_name(const std::string& value);
  void set_grammar_name(std::string&& value);
  void set_grammar_name(const char* value);
  void set_grammar_name(const char* value, size_t size);
  std::string* mutable_grammar_name();
  std::string* release_grammar_name();
  void set_allocated_grammar_name(std::string* grammar_name);

  // string grammar_data = 2;
  void clear_grammar_data();
  static const int kGrammarDataFieldNumber = 2;
  const std::string& grammar_data() const;
  void set_grammar_data(const std::string& value);
  void set_grammar_data(std::string&& value);
  void set_grammar_data(const char* value);
  void set_grammar_data(const char* value, size_t size);
  std::string* mutable_grammar_data();
  std::string* release_grammar_data();
  void set_allocated_grammar_data(std::string* grammar_data);

  // @@protoc_insertion_point(class_scope:techmo.sarmata.DefineGrammarRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr grammar_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr grammar_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sarmata_5fasr_2eproto;
};
// -------------------------------------------------------------------

class DefineGrammarResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:techmo.sarmata.DefineGrammarResponse) */ {
 public:
  DefineGrammarResponse();
  virtual ~DefineGrammarResponse();

  DefineGrammarResponse(const DefineGrammarResponse& from);
  DefineGrammarResponse(DefineGrammarResponse&& from) noexcept
    : DefineGrammarResponse() {
    *this = ::std::move(from);
  }

  inline DefineGrammarResponse& operator=(const DefineGrammarResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefineGrammarResponse& operator=(DefineGrammarResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DefineGrammarResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DefineGrammarResponse* internal_default_instance() {
    return reinterpret_cast<const DefineGrammarResponse*>(
               &_DefineGrammarResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DefineGrammarResponse* other);
  friend void swap(DefineGrammarResponse& a, DefineGrammarResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DefineGrammarResponse* New() const final {
    return CreateMaybeMessage<DefineGrammarResponse>(nullptr);
  }

  DefineGrammarResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DefineGrammarResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DefineGrammarResponse& from);
  void MergeFrom(const DefineGrammarResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefineGrammarResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "techmo.sarmata.DefineGrammarResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sarmata_5fasr_2eproto);
    return ::descriptor_table_sarmata_5fasr_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);

  // .techmo.sarmata.ResponseStatus status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::techmo::sarmata::ResponseStatus status() const;
  void set_status(::techmo::sarmata::ResponseStatus value);

  // bool ok = 3;
  void clear_ok();
  static const int kOkFieldNumber = 3;
  bool ok() const;
  void set_ok(bool value);

  // @@protoc_insertion_point(class_scope:techmo.sarmata.DefineGrammarResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  int status_;
  bool ok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sarmata_5fasr_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RecognizeRequest

// .techmo.sarmata.RecognitionConfig config = 1;
inline bool RecognizeRequest::has_config() const {
  return request_case() == kConfig;
}
inline void RecognizeRequest::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void RecognizeRequest::clear_config() {
  if (has_config()) {
    delete request_.config_;
    clear_has_request();
  }
}
inline ::techmo::sarmata::RecognitionConfig* RecognizeRequest::release_config() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.RecognizeRequest.config)
  if (has_config()) {
    clear_has_request();
      ::techmo::sarmata::RecognitionConfig* temp = request_.config_;
    request_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::techmo::sarmata::RecognitionConfig& RecognizeRequest::config() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizeRequest.config)
  return has_config()
      ? *request_.config_
      : *reinterpret_cast< ::techmo::sarmata::RecognitionConfig*>(&::techmo::sarmata::_RecognitionConfig_default_instance_);
}
inline ::techmo::sarmata::RecognitionConfig* RecognizeRequest::mutable_config() {
  if (!has_config()) {
    clear_request();
    set_has_config();
    request_.config_ = CreateMaybeMessage< ::techmo::sarmata::RecognitionConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.RecognizeRequest.config)
  return request_.config_;
}

// bytes audio_content = 2;
inline bool RecognizeRequest::has_audio_content() const {
  return request_case() == kAudioContent;
}
inline void RecognizeRequest::set_has_audio_content() {
  _oneof_case_[0] = kAudioContent;
}
inline void RecognizeRequest::clear_audio_content() {
  if (has_audio_content()) {
    request_.audio_content_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_request();
  }
}
inline const std::string& RecognizeRequest::audio_content() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizeRequest.audio_content)
  if (has_audio_content()) {
    return request_.audio_content_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RecognizeRequest::set_audio_content(const std::string& value) {
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizeRequest.audio_content)
  if (!has_audio_content()) {
    clear_request();
    set_has_audio_content();
    request_.audio_content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  request_.audio_content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizeRequest.audio_content)
}
inline void RecognizeRequest::set_audio_content(std::string&& value) {
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizeRequest.audio_content)
  if (!has_audio_content()) {
    clear_request();
    set_has_audio_content();
    request_.audio_content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  request_.audio_content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:techmo.sarmata.RecognizeRequest.audio_content)
}
inline void RecognizeRequest::set_audio_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_audio_content()) {
    clear_request();
    set_has_audio_content();
    request_.audio_content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  request_.audio_content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:techmo.sarmata.RecognizeRequest.audio_content)
}
inline void RecognizeRequest::set_audio_content(const void* value, size_t size) {
  if (!has_audio_content()) {
    clear_request();
    set_has_audio_content();
    request_.audio_content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  request_.audio_content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:techmo.sarmata.RecognizeRequest.audio_content)
}
inline std::string* RecognizeRequest::mutable_audio_content() {
  if (!has_audio_content()) {
    clear_request();
    set_has_audio_content();
    request_.audio_content_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.RecognizeRequest.audio_content)
  return request_.audio_content_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RecognizeRequest::release_audio_content() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.RecognizeRequest.audio_content)
  if (has_audio_content()) {
    clear_has_request();
    return request_.audio_content_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void RecognizeRequest::set_allocated_audio_content(std::string* audio_content) {
  if (has_request()) {
    clear_request();
  }
  if (audio_content != nullptr) {
    set_has_audio_content();
    request_.audio_content_.UnsafeSetDefault(audio_content);
  }
  // @@protoc_insertion_point(field_set_allocated:techmo.sarmata.RecognizeRequest.audio_content)
}

inline bool RecognizeRequest::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void RecognizeRequest::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline RecognizeRequest::RequestCase RecognizeRequest::request_case() const {
  return RecognizeRequest::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RecognitionConfig

// string grammar_name = 1;
inline bool RecognitionConfig::has_grammar_name() const {
  return grammar_case() == kGrammarName;
}
inline void RecognitionConfig::set_has_grammar_name() {
  _oneof_case_[0] = kGrammarName;
}
inline void RecognitionConfig::clear_grammar_name() {
  if (has_grammar_name()) {
    grammar_.grammar_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_grammar();
  }
}
inline const std::string& RecognitionConfig::grammar_name() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognitionConfig.grammar_name)
  if (has_grammar_name()) {
    return grammar_.grammar_name_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RecognitionConfig::set_grammar_name(const std::string& value) {
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognitionConfig.grammar_name)
  if (!has_grammar_name()) {
    clear_grammar();
    set_has_grammar_name();
    grammar_.grammar_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  grammar_.grammar_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognitionConfig.grammar_name)
}
inline void RecognitionConfig::set_grammar_name(std::string&& value) {
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognitionConfig.grammar_name)
  if (!has_grammar_name()) {
    clear_grammar();
    set_has_grammar_name();
    grammar_.grammar_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  grammar_.grammar_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:techmo.sarmata.RecognitionConfig.grammar_name)
}
inline void RecognitionConfig::set_grammar_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_grammar_name()) {
    clear_grammar();
    set_has_grammar_name();
    grammar_.grammar_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  grammar_.grammar_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:techmo.sarmata.RecognitionConfig.grammar_name)
}
inline void RecognitionConfig::set_grammar_name(const char* value, size_t size) {
  if (!has_grammar_name()) {
    clear_grammar();
    set_has_grammar_name();
    grammar_.grammar_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  grammar_.grammar_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:techmo.sarmata.RecognitionConfig.grammar_name)
}
inline std::string* RecognitionConfig::mutable_grammar_name() {
  if (!has_grammar_name()) {
    clear_grammar();
    set_has_grammar_name();
    grammar_.grammar_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.RecognitionConfig.grammar_name)
  return grammar_.grammar_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RecognitionConfig::release_grammar_name() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.RecognitionConfig.grammar_name)
  if (has_grammar_name()) {
    clear_has_grammar();
    return grammar_.grammar_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void RecognitionConfig::set_allocated_grammar_name(std::string* grammar_name) {
  if (has_grammar()) {
    clear_grammar();
  }
  if (grammar_name != nullptr) {
    set_has_grammar_name();
    grammar_.grammar_name_.UnsafeSetDefault(grammar_name);
  }
  // @@protoc_insertion_point(field_set_allocated:techmo.sarmata.RecognitionConfig.grammar_name)
}

// string grammar_data = 2;
inline bool RecognitionConfig::has_grammar_data() const {
  return grammar_case() == kGrammarData;
}
inline void RecognitionConfig::set_has_grammar_data() {
  _oneof_case_[0] = kGrammarData;
}
inline void RecognitionConfig::clear_grammar_data() {
  if (has_grammar_data()) {
    grammar_.grammar_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_grammar();
  }
}
inline const std::string& RecognitionConfig::grammar_data() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognitionConfig.grammar_data)
  if (has_grammar_data()) {
    return grammar_.grammar_data_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RecognitionConfig::set_grammar_data(const std::string& value) {
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognitionConfig.grammar_data)
  if (!has_grammar_data()) {
    clear_grammar();
    set_has_grammar_data();
    grammar_.grammar_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  grammar_.grammar_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognitionConfig.grammar_data)
}
inline void RecognitionConfig::set_grammar_data(std::string&& value) {
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognitionConfig.grammar_data)
  if (!has_grammar_data()) {
    clear_grammar();
    set_has_grammar_data();
    grammar_.grammar_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  grammar_.grammar_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:techmo.sarmata.RecognitionConfig.grammar_data)
}
inline void RecognitionConfig::set_grammar_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_grammar_data()) {
    clear_grammar();
    set_has_grammar_data();
    grammar_.grammar_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  grammar_.grammar_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:techmo.sarmata.RecognitionConfig.grammar_data)
}
inline void RecognitionConfig::set_grammar_data(const char* value, size_t size) {
  if (!has_grammar_data()) {
    clear_grammar();
    set_has_grammar_data();
    grammar_.grammar_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  grammar_.grammar_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:techmo.sarmata.RecognitionConfig.grammar_data)
}
inline std::string* RecognitionConfig::mutable_grammar_data() {
  if (!has_grammar_data()) {
    clear_grammar();
    set_has_grammar_data();
    grammar_.grammar_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.RecognitionConfig.grammar_data)
  return grammar_.grammar_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RecognitionConfig::release_grammar_data() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.RecognitionConfig.grammar_data)
  if (has_grammar_data()) {
    clear_has_grammar();
    return grammar_.grammar_data_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void RecognitionConfig::set_allocated_grammar_data(std::string* grammar_data) {
  if (has_grammar()) {
    clear_grammar();
  }
  if (grammar_data != nullptr) {
    set_has_grammar_data();
    grammar_.grammar_data_.UnsafeSetDefault(grammar_data);
  }
  // @@protoc_insertion_point(field_set_allocated:techmo.sarmata.RecognitionConfig.grammar_data)
}

// int32 sample_rate_hertz = 3;
inline void RecognitionConfig::clear_sample_rate_hertz() {
  sample_rate_hertz_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RecognitionConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognitionConfig.sample_rate_hertz)
  return sample_rate_hertz_;
}
inline void RecognitionConfig::set_sample_rate_hertz(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sample_rate_hertz_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognitionConfig.sample_rate_hertz)
}

// int32 max_alternatives = 4;
inline void RecognitionConfig::clear_max_alternatives() {
  max_alternatives_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RecognitionConfig::max_alternatives() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognitionConfig.max_alternatives)
  return max_alternatives_;
}
inline void RecognitionConfig::set_max_alternatives(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_alternatives_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognitionConfig.max_alternatives)
}

// double no_match_threshold = 5;
inline void RecognitionConfig::clear_no_match_threshold() {
  no_match_threshold_ = 0;
}
inline double RecognitionConfig::no_match_threshold() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognitionConfig.no_match_threshold)
  return no_match_threshold_;
}
inline void RecognitionConfig::set_no_match_threshold(double value) {
  
  no_match_threshold_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognitionConfig.no_match_threshold)
}

// .techmo.sarmata.TimeoutSettings timeout_settings = 6;
inline bool RecognitionConfig::has_timeout_settings() const {
  return this != internal_default_instance() && timeout_settings_ != nullptr;
}
inline void RecognitionConfig::clear_timeout_settings() {
  if (GetArenaNoVirtual() == nullptr && timeout_settings_ != nullptr) {
    delete timeout_settings_;
  }
  timeout_settings_ = nullptr;
}
inline const ::techmo::sarmata::TimeoutSettings& RecognitionConfig::timeout_settings() const {
  const ::techmo::sarmata::TimeoutSettings* p = timeout_settings_;
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognitionConfig.timeout_settings)
  return p != nullptr ? *p : *reinterpret_cast<const ::techmo::sarmata::TimeoutSettings*>(
      &::techmo::sarmata::_TimeoutSettings_default_instance_);
}
inline ::techmo::sarmata::TimeoutSettings* RecognitionConfig::release_timeout_settings() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.RecognitionConfig.timeout_settings)
  
  ::techmo::sarmata::TimeoutSettings* temp = timeout_settings_;
  timeout_settings_ = nullptr;
  return temp;
}
inline ::techmo::sarmata::TimeoutSettings* RecognitionConfig::mutable_timeout_settings() {
  
  if (timeout_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::techmo::sarmata::TimeoutSettings>(GetArenaNoVirtual());
    timeout_settings_ = p;
  }
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.RecognitionConfig.timeout_settings)
  return timeout_settings_;
}
inline void RecognitionConfig::set_allocated_timeout_settings(::techmo::sarmata::TimeoutSettings* timeout_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete timeout_settings_;
  }
  if (timeout_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      timeout_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout_settings, submessage_arena);
    }
    
  } else {
    
  }
  timeout_settings_ = timeout_settings;
  // @@protoc_insertion_point(field_set_allocated:techmo.sarmata.RecognitionConfig.timeout_settings)
}

// repeated .techmo.sarmata.ConfigField additional_settings = 7;
inline int RecognitionConfig::additional_settings_size() const {
  return additional_settings_.size();
}
inline void RecognitionConfig::clear_additional_settings() {
  additional_settings_.Clear();
}
inline ::techmo::sarmata::ConfigField* RecognitionConfig::mutable_additional_settings(int index) {
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.RecognitionConfig.additional_settings)
  return additional_settings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::ConfigField >*
RecognitionConfig::mutable_additional_settings() {
  // @@protoc_insertion_point(field_mutable_list:techmo.sarmata.RecognitionConfig.additional_settings)
  return &additional_settings_;
}
inline const ::techmo::sarmata::ConfigField& RecognitionConfig::additional_settings(int index) const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognitionConfig.additional_settings)
  return additional_settings_.Get(index);
}
inline ::techmo::sarmata::ConfigField* RecognitionConfig::add_additional_settings() {
  // @@protoc_insertion_point(field_add:techmo.sarmata.RecognitionConfig.additional_settings)
  return additional_settings_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::ConfigField >&
RecognitionConfig::additional_settings() const {
  // @@protoc_insertion_point(field_list:techmo.sarmata.RecognitionConfig.additional_settings)
  return additional_settings_;
}

inline bool RecognitionConfig::has_grammar() const {
  return grammar_case() != GRAMMAR_NOT_SET;
}
inline void RecognitionConfig::clear_has_grammar() {
  _oneof_case_[0] = GRAMMAR_NOT_SET;
}
inline RecognitionConfig::GrammarCase RecognitionConfig::grammar_case() const {
  return RecognitionConfig::GrammarCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TimeoutSettings

// int32 no_input_timeout = 1;
inline void TimeoutSettings::clear_no_input_timeout() {
  no_input_timeout_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TimeoutSettings::no_input_timeout() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.TimeoutSettings.no_input_timeout)
  return no_input_timeout_;
}
inline void TimeoutSettings::set_no_input_timeout(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  no_input_timeout_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.TimeoutSettings.no_input_timeout)
}

// int32 recognition_timeout = 2;
inline void TimeoutSettings::clear_recognition_timeout() {
  recognition_timeout_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TimeoutSettings::recognition_timeout() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.TimeoutSettings.recognition_timeout)
  return recognition_timeout_;
}
inline void TimeoutSettings::set_recognition_timeout(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  recognition_timeout_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.TimeoutSettings.recognition_timeout)
}

// int32 speech_complete_timeout = 3;
inline void TimeoutSettings::clear_speech_complete_timeout() {
  speech_complete_timeout_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TimeoutSettings::speech_complete_timeout() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.TimeoutSettings.speech_complete_timeout)
  return speech_complete_timeout_;
}
inline void TimeoutSettings::set_speech_complete_timeout(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  speech_complete_timeout_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.TimeoutSettings.speech_complete_timeout)
}

// int32 speech_incomplete_timeout = 4;
inline void TimeoutSettings::clear_speech_incomplete_timeout() {
  speech_incomplete_timeout_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TimeoutSettings::speech_incomplete_timeout() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.TimeoutSettings.speech_incomplete_timeout)
  return speech_incomplete_timeout_;
}
inline void TimeoutSettings::set_speech_incomplete_timeout(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  speech_incomplete_timeout_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.TimeoutSettings.speech_incomplete_timeout)
}

// -------------------------------------------------------------------

// ConfigField

// string key = 1;
inline void ConfigField::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConfigField::key() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.ConfigField.key)
  return key_.GetNoArena();
}
inline void ConfigField::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:techmo.sarmata.ConfigField.key)
}
inline void ConfigField::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:techmo.sarmata.ConfigField.key)
}
inline void ConfigField::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:techmo.sarmata.ConfigField.key)
}
inline void ConfigField::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:techmo.sarmata.ConfigField.key)
}
inline std::string* ConfigField::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.ConfigField.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConfigField::release_key() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.ConfigField.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigField::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:techmo.sarmata.ConfigField.key)
}

// string value = 2;
inline void ConfigField::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConfigField::value() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.ConfigField.value)
  return value_.GetNoArena();
}
inline void ConfigField::set_value(const std::string& value) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:techmo.sarmata.ConfigField.value)
}
inline void ConfigField::set_value(std::string&& value) {
  
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:techmo.sarmata.ConfigField.value)
}
inline void ConfigField::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:techmo.sarmata.ConfigField.value)
}
inline void ConfigField::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:techmo.sarmata.ConfigField.value)
}
inline std::string* ConfigField::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.ConfigField.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConfigField::release_value() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.ConfigField.value)
  
  return value_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigField::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:techmo.sarmata.ConfigField.value)
}

// -------------------------------------------------------------------

// RecognizeResponse

// .techmo.sarmata.ResponseStatus status = 1;
inline void RecognizeResponse::clear_status() {
  status_ = 0;
}
inline ::techmo::sarmata::ResponseStatus RecognizeResponse::status() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizeResponse.status)
  return static_cast< ::techmo::sarmata::ResponseStatus >(status_);
}
inline void RecognizeResponse::set_status(::techmo::sarmata::ResponseStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizeResponse.status)
}

// string error = 2;
inline void RecognizeResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RecognizeResponse::error() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizeResponse.error)
  return error_.GetNoArena();
}
inline void RecognizeResponse::set_error(const std::string& value) {
  
  error_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizeResponse.error)
}
inline void RecognizeResponse::set_error(std::string&& value) {
  
  error_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:techmo.sarmata.RecognizeResponse.error)
}
inline void RecognizeResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:techmo.sarmata.RecognizeResponse.error)
}
inline void RecognizeResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:techmo.sarmata.RecognizeResponse.error)
}
inline std::string* RecognizeResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.RecognizeResponse.error)
  return error_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RecognizeResponse::release_error() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.RecognizeResponse.error)
  
  return error_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizeResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:techmo.sarmata.RecognizeResponse.error)
}

// int32 event_time = 3;
inline void RecognizeResponse::clear_event_time() {
  event_time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RecognizeResponse::event_time() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizeResponse.event_time)
  return event_time_;
}
inline void RecognizeResponse::set_event_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  event_time_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizeResponse.event_time)
}

// repeated .techmo.sarmata.RecognizedPhrase results = 4;
inline int RecognizeResponse::results_size() const {
  return results_.size();
}
inline void RecognizeResponse::clear_results() {
  results_.Clear();
}
inline ::techmo::sarmata::RecognizedPhrase* RecognizeResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.RecognizeResponse.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::RecognizedPhrase >*
RecognizeResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:techmo.sarmata.RecognizeResponse.results)
  return &results_;
}
inline const ::techmo::sarmata::RecognizedPhrase& RecognizeResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizeResponse.results)
  return results_.Get(index);
}
inline ::techmo::sarmata::RecognizedPhrase* RecognizeResponse::add_results() {
  // @@protoc_insertion_point(field_add:techmo.sarmata.RecognizeResponse.results)
  return results_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::RecognizedPhrase >&
RecognizeResponse::results() const {
  // @@protoc_insertion_point(field_list:techmo.sarmata.RecognizeResponse.results)
  return results_;
}

// -------------------------------------------------------------------

// RecognizedPhrase_RecognizedWord

// string transcript = 1;
inline void RecognizedPhrase_RecognizedWord::clear_transcript() {
  transcript_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RecognizedPhrase_RecognizedWord::transcript() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizedPhrase.RecognizedWord.transcript)
  return transcript_.GetNoArena();
}
inline void RecognizedPhrase_RecognizedWord::set_transcript(const std::string& value) {
  
  transcript_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizedPhrase.RecognizedWord.transcript)
}
inline void RecognizedPhrase_RecognizedWord::set_transcript(std::string&& value) {
  
  transcript_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:techmo.sarmata.RecognizedPhrase.RecognizedWord.transcript)
}
inline void RecognizedPhrase_RecognizedWord::set_transcript(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transcript_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:techmo.sarmata.RecognizedPhrase.RecognizedWord.transcript)
}
inline void RecognizedPhrase_RecognizedWord::set_transcript(const char* value, size_t size) {
  
  transcript_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:techmo.sarmata.RecognizedPhrase.RecognizedWord.transcript)
}
inline std::string* RecognizedPhrase_RecognizedWord::mutable_transcript() {
  
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.RecognizedPhrase.RecognizedWord.transcript)
  return transcript_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RecognizedPhrase_RecognizedWord::release_transcript() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.RecognizedPhrase.RecognizedWord.transcript)
  
  return transcript_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizedPhrase_RecognizedWord::set_allocated_transcript(std::string* transcript) {
  if (transcript != nullptr) {
    
  } else {
    
  }
  transcript_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transcript);
  // @@protoc_insertion_point(field_set_allocated:techmo.sarmata.RecognizedPhrase.RecognizedWord.transcript)
}

// double confidence = 2;
inline void RecognizedPhrase_RecognizedWord::clear_confidence() {
  confidence_ = 0;
}
inline double RecognizedPhrase_RecognizedWord::confidence() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizedPhrase.RecognizedWord.confidence)
  return confidence_;
}
inline void RecognizedPhrase_RecognizedWord::set_confidence(double value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizedPhrase.RecognizedWord.confidence)
}

// int32 start = 3;
inline void RecognizedPhrase_RecognizedWord::clear_start() {
  start_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RecognizedPhrase_RecognizedWord::start() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizedPhrase.RecognizedWord.start)
  return start_;
}
inline void RecognizedPhrase_RecognizedWord::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizedPhrase.RecognizedWord.start)
}

// int32 end = 4;
inline void RecognizedPhrase_RecognizedWord::clear_end() {
  end_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RecognizedPhrase_RecognizedWord::end() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizedPhrase.RecognizedWord.end)
  return end_;
}
inline void RecognizedPhrase_RecognizedWord::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizedPhrase.RecognizedWord.end)
}

// double logprob = 5;
inline void RecognizedPhrase_RecognizedWord::clear_logprob() {
  logprob_ = 0;
}
inline double RecognizedPhrase_RecognizedWord::logprob() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizedPhrase.RecognizedWord.logprob)
  return logprob_;
}
inline void RecognizedPhrase_RecognizedWord::set_logprob(double value) {
  
  logprob_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizedPhrase.RecognizedWord.logprob)
}

// -------------------------------------------------------------------

// RecognizedPhrase

// repeated .techmo.sarmata.RecognizedPhrase.RecognizedWord words = 1;
inline int RecognizedPhrase::words_size() const {
  return words_.size();
}
inline void RecognizedPhrase::clear_words() {
  words_.Clear();
}
inline ::techmo::sarmata::RecognizedPhrase_RecognizedWord* RecognizedPhrase::mutable_words(int index) {
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.RecognizedPhrase.words)
  return words_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::RecognizedPhrase_RecognizedWord >*
RecognizedPhrase::mutable_words() {
  // @@protoc_insertion_point(field_mutable_list:techmo.sarmata.RecognizedPhrase.words)
  return &words_;
}
inline const ::techmo::sarmata::RecognizedPhrase_RecognizedWord& RecognizedPhrase::words(int index) const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizedPhrase.words)
  return words_.Get(index);
}
inline ::techmo::sarmata::RecognizedPhrase_RecognizedWord* RecognizedPhrase::add_words() {
  // @@protoc_insertion_point(field_add:techmo.sarmata.RecognizedPhrase.words)
  return words_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::techmo::sarmata::RecognizedPhrase_RecognizedWord >&
RecognizedPhrase::words() const {
  // @@protoc_insertion_point(field_list:techmo.sarmata.RecognizedPhrase.words)
  return words_;
}

// double confidence = 2;
inline void RecognizedPhrase::clear_confidence() {
  confidence_ = 0;
}
inline double RecognizedPhrase::confidence() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizedPhrase.confidence)
  return confidence_;
}
inline void RecognizedPhrase::set_confidence(double value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizedPhrase.confidence)
}

// bool correct = 3;
inline void RecognizedPhrase::clear_correct() {
  correct_ = false;
}
inline bool RecognizedPhrase::correct() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizedPhrase.correct)
  return correct_;
}
inline void RecognizedPhrase::set_correct(bool value) {
  
  correct_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizedPhrase.correct)
}

// string semantic_interpretation = 4;
inline void RecognizedPhrase::clear_semantic_interpretation() {
  semantic_interpretation_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RecognizedPhrase::semantic_interpretation() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.RecognizedPhrase.semantic_interpretation)
  return semantic_interpretation_.GetNoArena();
}
inline void RecognizedPhrase::set_semantic_interpretation(const std::string& value) {
  
  semantic_interpretation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:techmo.sarmata.RecognizedPhrase.semantic_interpretation)
}
inline void RecognizedPhrase::set_semantic_interpretation(std::string&& value) {
  
  semantic_interpretation_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:techmo.sarmata.RecognizedPhrase.semantic_interpretation)
}
inline void RecognizedPhrase::set_semantic_interpretation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  semantic_interpretation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:techmo.sarmata.RecognizedPhrase.semantic_interpretation)
}
inline void RecognizedPhrase::set_semantic_interpretation(const char* value, size_t size) {
  
  semantic_interpretation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:techmo.sarmata.RecognizedPhrase.semantic_interpretation)
}
inline std::string* RecognizedPhrase::mutable_semantic_interpretation() {
  
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.RecognizedPhrase.semantic_interpretation)
  return semantic_interpretation_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RecognizedPhrase::release_semantic_interpretation() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.RecognizedPhrase.semantic_interpretation)
  
  return semantic_interpretation_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizedPhrase::set_allocated_semantic_interpretation(std::string* semantic_interpretation) {
  if (semantic_interpretation != nullptr) {
    
  } else {
    
  }
  semantic_interpretation_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), semantic_interpretation);
  // @@protoc_insertion_point(field_set_allocated:techmo.sarmata.RecognizedPhrase.semantic_interpretation)
}

// -------------------------------------------------------------------

// DefineGrammarRequest

// string grammar_name = 1;
inline void DefineGrammarRequest::clear_grammar_name() {
  grammar_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DefineGrammarRequest::grammar_name() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.DefineGrammarRequest.grammar_name)
  return grammar_name_.GetNoArena();
}
inline void DefineGrammarRequest::set_grammar_name(const std::string& value) {
  
  grammar_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:techmo.sarmata.DefineGrammarRequest.grammar_name)
}
inline void DefineGrammarRequest::set_grammar_name(std::string&& value) {
  
  grammar_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:techmo.sarmata.DefineGrammarRequest.grammar_name)
}
inline void DefineGrammarRequest::set_grammar_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  grammar_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:techmo.sarmata.DefineGrammarRequest.grammar_name)
}
inline void DefineGrammarRequest::set_grammar_name(const char* value, size_t size) {
  
  grammar_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:techmo.sarmata.DefineGrammarRequest.grammar_name)
}
inline std::string* DefineGrammarRequest::mutable_grammar_name() {
  
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.DefineGrammarRequest.grammar_name)
  return grammar_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DefineGrammarRequest::release_grammar_name() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.DefineGrammarRequest.grammar_name)
  
  return grammar_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarRequest::set_allocated_grammar_name(std::string* grammar_name) {
  if (grammar_name != nullptr) {
    
  } else {
    
  }
  grammar_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), grammar_name);
  // @@protoc_insertion_point(field_set_allocated:techmo.sarmata.DefineGrammarRequest.grammar_name)
}

// string grammar_data = 2;
inline void DefineGrammarRequest::clear_grammar_data() {
  grammar_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DefineGrammarRequest::grammar_data() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.DefineGrammarRequest.grammar_data)
  return grammar_data_.GetNoArena();
}
inline void DefineGrammarRequest::set_grammar_data(const std::string& value) {
  
  grammar_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:techmo.sarmata.DefineGrammarRequest.grammar_data)
}
inline void DefineGrammarRequest::set_grammar_data(std::string&& value) {
  
  grammar_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:techmo.sarmata.DefineGrammarRequest.grammar_data)
}
inline void DefineGrammarRequest::set_grammar_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  grammar_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:techmo.sarmata.DefineGrammarRequest.grammar_data)
}
inline void DefineGrammarRequest::set_grammar_data(const char* value, size_t size) {
  
  grammar_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:techmo.sarmata.DefineGrammarRequest.grammar_data)
}
inline std::string* DefineGrammarRequest::mutable_grammar_data() {
  
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.DefineGrammarRequest.grammar_data)
  return grammar_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DefineGrammarRequest::release_grammar_data() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.DefineGrammarRequest.grammar_data)
  
  return grammar_data_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarRequest::set_allocated_grammar_data(std::string* grammar_data) {
  if (grammar_data != nullptr) {
    
  } else {
    
  }
  grammar_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), grammar_data);
  // @@protoc_insertion_point(field_set_allocated:techmo.sarmata.DefineGrammarRequest.grammar_data)
}

// -------------------------------------------------------------------

// DefineGrammarResponse

// .techmo.sarmata.ResponseStatus status = 1;
inline void DefineGrammarResponse::clear_status() {
  status_ = 0;
}
inline ::techmo::sarmata::ResponseStatus DefineGrammarResponse::status() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.DefineGrammarResponse.status)
  return static_cast< ::techmo::sarmata::ResponseStatus >(status_);
}
inline void DefineGrammarResponse::set_status(::techmo::sarmata::ResponseStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.DefineGrammarResponse.status)
}

// string error = 2;
inline void DefineGrammarResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& DefineGrammarResponse::error() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.DefineGrammarResponse.error)
  return error_.GetNoArena();
}
inline void DefineGrammarResponse::set_error(const std::string& value) {
  
  error_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:techmo.sarmata.DefineGrammarResponse.error)
}
inline void DefineGrammarResponse::set_error(std::string&& value) {
  
  error_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:techmo.sarmata.DefineGrammarResponse.error)
}
inline void DefineGrammarResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:techmo.sarmata.DefineGrammarResponse.error)
}
inline void DefineGrammarResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:techmo.sarmata.DefineGrammarResponse.error)
}
inline std::string* DefineGrammarResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:techmo.sarmata.DefineGrammarResponse.error)
  return error_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DefineGrammarResponse::release_error() {
  // @@protoc_insertion_point(field_release:techmo.sarmata.DefineGrammarResponse.error)
  
  return error_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DefineGrammarResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:techmo.sarmata.DefineGrammarResponse.error)
}

// bool ok = 3;
inline void DefineGrammarResponse::clear_ok() {
  ok_ = false;
}
inline bool DefineGrammarResponse::ok() const {
  // @@protoc_insertion_point(field_get:techmo.sarmata.DefineGrammarResponse.ok)
  return ok_;
}
inline void DefineGrammarResponse::set_ok(bool value) {
  
  ok_ = value;
  // @@protoc_insertion_point(field_set:techmo.sarmata.DefineGrammarResponse.ok)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sarmata
}  // namespace techmo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::techmo::sarmata::ResponseStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::techmo::sarmata::ResponseStatus>() {
  return ::techmo::sarmata::ResponseStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sarmata_5fasr_2eproto
